version: '3.1'
responses:
  utter_versioning_patterns:
    - custom:
        vr_pt: |
          Os padrões de versionamento definem diferentes formas de controlar e disponibilizar novas versões de uma API ao longo do tempo. O primeiro padrão é o versionamento semântico, que utiliza três números separados por ponto por extenso: o primeiro número é chamado de major, o segundo é o minor e o terceiro é o patch. Por exemplo, versão um ponto zero ponto zero indica a primeira versão estável, e versão um ponto um ponto zero indicaria uma melhoria menor. O segundo padrão é o versionamento por URI, que insere uma barra seguida da letra v e do número da versão por extenso antes do caminho do recurso. Por exemplo, barra v um barra pedidos identifica a versão um da API de pedidos. O terceiro padrão é o versionamento por cabeçalho, em que o cliente envia junto com a requisição um cabeçalho chamado Accept Versão dois pontos seguido do número da versão por extenso. Por exemplo, Accept Versão dois pontos um informa ao servidor que o cliente deseja a versão um da API. O quarto padrão é o versionamento por tipo de mídia, que inclui a versão no tipo de mídia do conteúdo. Nesse caso, o cabeçalho Content Type ou Accept recebe um valor como application barra vnd ponto myapi ponto v um mais json, indicando que o cliente aceita ou envia dados no formato da versão um. O quinto padrão é o versionamento por parâmetro de consulta, em que a URL de requisição recebe uma interrogação seguida de version igual e do número da versão por extenso. Por exemplo, interrogação version igual um no fim da URL informa a versão um da API. Cada um desses padrões afeta de maneira diferente o comportamento de cache, a facilidade de descoberta dos recursos e a compatibilidade entre consumidores antigos e novas versões, exigindo escolhas conscientes conforme as necessidades do projeto.
        vr_en: |
          Versioning patterns define different ways to manage and expose new versions of an API over time. The first pattern is semantic versioning, which uses three numbers spoken in full separated by dots: the first number is called major, the second is minor and the third is patch. For example, version one dot zero dot zero indicates the first stable release, and version one dot one dot zero would indicate a minor enhancement. The second pattern is URI versioning, which inserts a slash followed by the letter v and the version number in full before the resource path. For example, slash v one slash orders identifies version one of the orders API. The third pattern is header versioning, where the client sends a header named Accept Version colon followed by the version number in full. For example, Accept Version colon one tells the server that the client is requesting version one of the API. The fourth pattern is media type versioning, which includes the version in the content media type. In this case the Content Type or Accept header carries a value such as application slash vnd dot myapi dot v one plus json, indicating that the client accepts or sends data in version one format. The fifth pattern is query parameter versioning, where the request URL includes a question mark followed by version equals and the version number in full. For example, question mark version equals one at the end of the URL requests version one of the API. Each of these patterns has a distinct impact on caching behavior, resource discoverability and compatibility between legacy consumers and newer versions, so choosing the right approach depends on the specific needs of the project.
    - custom:
        vr_pt: |
          Os padrões de versionamento seguem convenções que permitem distinguir claramente cada atualização de uma API ao longo do tempo. O primeiro padrão é o versionamento semântico, que incrementa por extenso três números na ordem de importância: major ponto minor ponto patch. Por exemplo, ao passar de uma versão um ponto zero ponto zero para uma versão dois ponto zero ponto zero, você indica uma mudança de impacto elevado. Ao ir para uma versão um ponto um ponto zero, sinaliza adição de funcionalidade de forma compatível com versões anteriores. E ao atualizar para uma versão um ponto zero ponto um, indica correções ou ajustes pequenos. O segundo padrão é o versionamento por URI. Nesse caso, a URL do serviço inclui uma barra seguida da letra v e do número da versão, por extenso, antes do recurso. Por exemplo, barra v dois barra pedidos identifica a segunda versão do serviço de pedidos. O terceiro padrão é o versionamento por cabeçalho HTTP. O cliente envia na requisição um cabeçalho chamado Accept Versão dois pontos dois, indicando que deseja a segunda versão da API. O quarto padrão é o versionamento por tipo de mídia. Aqui, a versão faz parte do valor do cabeçalho Content Type ou Accept, por exemplo application barra vnd ponto myapi ponto v dois mais json, sinalizando que o corpo da mensagem segue o formato da segunda versão. O quinto padrão é o versionamento por parâmetro de consulta. A URL recebe uma interrogação seguida da palavra version igual dois, como em barra pedidos interrogação version igual dois, especificando a segunda versão do serviço. Cada uma dessas abordagens impacta de modo diferente o comportamento de cache, a descoberta de endpoints e a compatibilidade com clientes antigos, por isso a escolha deve considerar fatores como requisitos de deployment, roteamento e manutenção a longo prazo.
        vr_en: |
          Versioning patterns follow conventions that allow each API update to be clearly distinguished over time. The first pattern is semantic versioning, which increments three numbers spoken in full in order of importance: major dot minor dot patch. For example, moving from version one dot zero dot zero to version two dot zero dot zero indicates a major breaking change. Moving to version one dot one dot zero signals a backward compatible feature addition. And upgrading to version one dot zero dot one indicates small fixes or patches. The second pattern is URI versioning. In this case, the service URL includes a slash followed by the letter v and the version number in full before the resource. For example, slash v two slash orders identifies the second version of the orders service. The third pattern is HTTP header versioning. The client sends a header named Accept Version colon two to indicate it wants the second version of the API. The fourth pattern is media type versioning. Here the version is embedded in the Content Type or Accept header value, for example application slash vnd dot myapi dot v two plus json, indicating that the message body follows the second version format. The fifth pattern is query parameter versioning. The URL includes a question mark followed by version equals two, as in slash orders question mark version equals two, specifying the second version of the service. Each of these approaches affects caching behavior, endpoint discoverability and backward compatibility differently, so the choice should consider factors such as deployment strategy, routing requirements and long term maintenance.
    - custom:
        vr_pt: |
          O versionamento semântico segue o formato numero ponto numero ponto numero, onde o primeiro número indica mudanças que quebram a compatibilidade, o segundo número indica adição de funcionalidades compatíveis e o terceiro número indica correções ou ajustes pequenos. No versionamento por uniform resource identifier, antes do nome do recurso insere-se a palavra barra seguida da letra v e do número tres, por exemplo barra v tres barra pedidos identifica a terceira versão do serviço de pedidos. No versionamento por cabeçalho, o cliente inclui na requisição um cabeçalho chamado Accept Versão dois pontos tres, informando que deseja usar a terceira versão da API. No versionamento por tipo de mídia, adiciona-se a versão no valor do cabeçalho Content Type ou do cabeçalho Accept como application barra vnd ponto myapi ponto v tres mais json, indicando que o corpo da mensagem segue o formato da terceira versão. No versionamento por cadeia de consulta, acrescenta-se ao final da URL uma interrogação seguida de version igual tres, por exemplo barra pedidos interrogação version igual tres, definindo a terceira versão do serviço. Cada uma dessas abordagens afeta de forma diferente o roteamento das requisições e a compatibilidade com clientes antigos, sendo importante escolher a opção mais adequada ao contexto do projeto.
        vr_en: |
          Semantic versioning follows the format number dot number dot number, where the first number indicates breaking changes, the second number indicates backward compatible feature additions, and the third number indicates patches or minor fixes. In URI versioning, you insert the word slash followed by the letter v and the number three before the resource name, for example slash v three slash orders identifies the third version of the orders API. In header versioning, the client includes a header called Accept Version colon three in the request, indicating that it wants to use the third version of the API. In media type versioning, you include the version in the Content Type or Accept header value, for example application slash vnd dot myapi dot v three plus json, indicating that the message body uses the third version format. In query string versioning, you add a question mark followed by version equals three at the end of the URL, for example slash orders question mark version equals three, specifying the third version of the service. Each of these approaches impacts request routing and backward compatibility differently, so it is important to choose the option that best fits the project context.
    - custom:
        vr_pt: |
          O versionamento semântico segue o formato número ponto número ponto número, em que o primeiro número indica mudanças incompatíveis, o segundo número indica adição de funcionalidades compatíveis e o terceiro número indica correções pequenas. O versionamento por URI insere antes do caminho do recurso a letra v seguida de quatro por extenso, por exemplo barra v quatro barra pedidos identifica a quarta versão do serviço de pedidos. O versionamento por cabeçalho HTTP utiliza um cabeçalho chamado Accept Versão dois pontos quatro, indicando que o cliente deseja a quarta versão da API. O versionamento por tipo de mídia inclui a versão no valor do cabeçalho Content Type ou Accept, usando uma sequência como application barra vnd ponto myapi ponto v quatro mais json para sinalizar que o corpo da mensagem segue o formato da quarta versão. O versionamento por parâmetro de consulta acrescenta ao final da URL uma interrogação seguida da palavra version igual quatro, por exemplo barra pedidos interrogação version igual quatro, especificando a quarta versão do serviço. Cada uma dessas abordagens afeta de maneira diferente o comportamento de cache em proxies e clientes intermediários, a facilidade de descoberta dos endpoints e a compatibilidade com consumidores antigos, sendo fundamental escolher o padrão que melhor atende aos requisitos de desempenho, roteamento e manutenção de longo prazo.
        vr_en: |
          Semantic versioning follows the format number dot number dot number, where the first number indicates breaking changes, the second number indicates backward-compatible feature additions, and the third number indicates minor fixes. URI versioning inserts the letter v followed by four in full before the resource path, for example slash v four slash orders identifies the fourth version of the orders service. Header versioning uses an HTTP header named Accept Version colon four, indicating that the client is requesting version four of the API. Media type versioning embeds the version in the Content Type or Accept header value, using a string such as application slash vnd dot myapi dot v four plus json to signal that the message payload follows the fourth version format. Query parameter versioning appends a question mark followed by version equals four at the end of the URL, for example slash orders question mark version equals four, specifying the fourth version of the service. Each of these approaches impacts caching behavior in proxies and intermediate clients, endpoint discoverability and compatibility with legacy consumers in unique ways, making it crucial to choose the pattern that best fits long-term performance, routing and maintenance requirements.
    - custom:
        vr_pt: |
          O SemVer adota o formato major ponto minor ponto patch por extenso, onde o primeiro número representa mudanças incompatíveis, o segundo número indica novas funcionalidades compatíveis e o terceiro número sinaliza correções ou ajustes pequenos. No padrão de versionamento por Uniform Resource Identifier, insere-se a palavra barra seguida da letra v e do número cinco por extenso antes do nome de cada recurso de API. Por exemplo, barra v cinco barra pedidos identifica a quinta versão da API de pedidos. No versionamento por cabeçalho HTTP, o cliente inclui na requisição um campo chamado Accept Versão dois pontos cinco por extenso, informando que deseja a quinta versão da API. No versionamento por tipo de mídia, a versão faz parte do valor do cabeçalho Content Type ou do cabeçalho Accept, escrito application barra vnd ponto myapi ponto v cinco mais json por extenso, indicando que o corpo da mensagem está no formato da quinta versão. No versionamento por parâmetro de consulta, acrescenta-se ao final da URL uma interrogação seguida de version igual cinco por extenso, como em barra pedidos interrogação version igual cinco, especificando a quinta versão do serviço. Cada um desses padrões afeta de maneira distinta o comportamento de cache em proxies e navegadores, a descoberta de novos endpoints e a compatibilidade com clientes que ainda usam versões anteriores, exigindo uma escolha cuidadosa conforme as necessidades de desempenho, manutenção e escalabilidade do projeto.
        vr_en: |
          Semantic versioning uses the format major dot minor dot patch spoken in full, where the first number represents breaking changes, the second number indicates compatible feature additions, and the third number signals small patches or fixes. In URI versioning, you insert the words forward slash followed by the letter v and the number five in full before each API resource name. For example, forward slash v five forward slash orders denotes the fifth version of the orders API. In HTTP header versioning, the client sends a header named Accept Version colon five in full to request the fifth version of the API. In media type versioning, the version appears in the Content Type or Accept header value as the words application slash vnd dot myapi dot v five plus json spoken in full, indicating that the message payload uses the fifth version format. In query parameter versioning, you append a question mark followed by version equals five in full at the end of the URL, such as forward slash orders question mark version equals five, specifying the fifth version of the service. Each of these approaches impacts caching behavior in proxies and browsers, endpoint discoverability and backward compatibility with clients still using earlier versions differently, so selecting the right pattern depends on project requirements for performance, maintenance and scalability.
    - custom:
        vr_pt: |
          O versionamento semântico utiliza três números escritos por extenso separados pela palavra ponto: major ponto minor ponto patch. Quando chegamos à sexta versão, escrevemos seis ponto zero ponto zero para indicar que a versão seis inclui mudanças que não são compatíveis com versões anteriores. No versionamento por URL, inserimos a letra v seguida da palavra seis por extenso antes do caminho do recurso na barra de endereço. Por exemplo, barra v seis barra pedidos indica que estamos na sexta versão da API de pedidos. No versionamento por cabeçalho HTTP, o cliente envia um campo chamado Accept Versão seguido dos dois pontos e da palavra seis por extenso. Esse cabeçalho informa ao servidor que a aplicação deseja usar a versão seis da API. No versionamento por tipo de mídia, a versão é incorporada ao valor do cabeçalho Content Type ou do cabeçalho Accept. Escrevemos application barra vnd ponto myapi ponto v seis mais json por extenso para sinalizar que o corpo da mensagem está no formato da sexta versão. No versionamento por parâmetro de consulta, acrescentamos ao final da URL uma interrogação seguida da palavra version igual e da palavra seis por extenso. Por exemplo, barra pedidos interrogação version igual seis indica a sexta versão do serviço. Cada uma dessas técnicas impacta de forma distinta o comportamento de cache em redes de distribuição de conteúdo, pois proxies e caches podem armazenar separadamente as respostas de cada versão. No versionamento por URL, a própria URL muda e o cache trata cada versão como recurso diferente. No versionamento por cabeçalho, é necessário que o cache seja configurado para considerar o valor do cabeçalho na chave de armazenamento. No versionamento por tipo de mídia, caches devem analisar o conteúdo do cabeçalho Content Type. E no versionamento por parâmetro de consulta, o cache vê a string de consulta como parte do recurso, separando também as versões.
        vr_en: |
          Semantic versioning uses three numbers written in full separated by the word dot: major dot minor dot patch. When we reach the sixth version we write six dot zero dot zero to indicate that version six includes changes that are not backward compatible. In URI versioning we insert the letter v followed by the word six in full before the resource path in the address bar. For example slash v six slash orders shows that we are using the sixth version of the orders API. In HTTP header versioning the client sends a header named Accept Version colon followed by the word six in full. This header tells the server that the application wants to use version six of the API. In media type versioning the version is embedded in the Content Type or Accept header value. We write application slash vnd dot myapi dot v six plus json in full to signal that the message payload follows the sixth version format. In query parameter versioning we append a question mark followed by version equals and the word six in full at the end of the URL. For example slash orders question mark version equals six specifies version six of the service. Each of these techniques affects how content delivery network caches handle responses. With URI versioning the URL itself changes so each version is treated as a separate resource in the cache. With header versioning caches must be configured to include the header value in their storage key. With media type versioning caches look at the Content Type header. And with query parameter versioning the cache key includes the query string, separating each version’s responses accordingly.
    - custom:
        vr_pt: |
          O versionamento semântico segue o formato numero ponto numero ponto numero, onde o primeiro número indica mudanças incompatíveis, o segundo número representa acréscimos de funcionalidades compatíveis e o terceiro número sinaliza correções ou ajustes pequenos. Quando falamos de sete ponto zero ponto zero, estamos na sétima versão principal da API. No versionamento por Uniform Resource Identifier, antes do nome do recurso adiciona-se a palavra barra seguida da letra v e da palavra sete por extenso. Por exemplo, barra v sete barra pedidos identifica a sétima versão do serviço de pedidos. No versionamento por cabeçalho HTTP, o cliente inclui na requisição um campo com o nome Accept Versão seguido de dois pontos e da palavra sete por extenso, informando ao servidor que deseja usar a sétima versão da API. No versionamento por tipo de mídia, a versão faz parte do valor do cabeçalho Content Type ou do cabeçalho Accept. Nesse caso escrevemos application barra vnd ponto myapi ponto v sete mais json por extenso para sinalizar que o corpo da mensagem segue o formato da sétima versão. No versionamento por parâmetro de consulta, acrescenta-se ao final da URL uma interrogação seguida da palavra version igual e da palavra sete por extenso. Por exemplo, barra pedidos interrogação version igual sete aponta a sétima versão do serviço. Cada uma dessas abordagens afeta de maneira diferente o roteamento das requisições e o consumo da API. No versionamento por URI a própria rota muda e proxies e caches tratam cada versão como recurso distinto. No versionamento por cabeçalho, é preciso configurar intermediários para considerar o valor do cabeçalho na chave de cache. No versionamento por tipo de mídia, o cabeçalho Content Type passa a ser o critério. E no versionamento por parâmetro de consulta, a string de consulta faz parte da chave de cache e de roteamento, isolando versões diferentes.
        vr_en: |
          Semantic versioning follows the format number dot number dot number, where the first number indicates breaking changes, the second number represents backward-compatible feature additions, and the third number signals patches or minor fixes. When we refer to seven dot zero dot zero we are on the seventh major version of the API. In URI versioning, you insert the word slash followed by the letter v and the word seven in full before the resource name. For example, slash v seven slash orders identifies version seven of the orders service. In HTTP header versioning, the client includes a header named Accept Version colon followed by the word seven in full, telling the server that it is requesting version seven of the API. In media type versioning, the version is embedded in the Content Type or Accept header value. We write application slash vnd dot myapi dot v seven plus json in full to signal that the message payload follows the format of version seven. In query parameter versioning, you append a question mark followed by version equals and the word seven in full at the end of the URL. For example, slash orders question mark version equals seven specifies version seven of the service. Each of these approaches impacts request routing and consumption behavior differently. In URI versioning the route itself changes and proxies and caches treat each version as a separate resource. In header versioning intermediaries must be configured to include the header value in the cache key. In media type versioning the Content Type header becomes the criterion. And in query parameter versioning the query string is part of the route and cache key, isolating different versions.
    - custom:
        vr_pt: |
          O versionamento semântico utiliza três números por extenso separados pela palavra ponto na ordem de importância: major ponto minor ponto patch. Por exemplo, versão oito ponto zero ponto zero indica a oitava versão principal da API, onde mudanças incompatíveis podem ocorrer. No versionamento por URI, antes do caminho de cada recurso insere-se a barra seguida da letra v e da palavra oito por extenso. Por exemplo, barra v oito barra pedidos identifica que você está acessando a oitava versão da API de pedidos. No versionamento por cabeçalho HTTP, o cliente inclui na requisição um cabeçalho chamado Accept Versão dois pontos oito por extenso, informando ao servidor que deseja utilizar a oitava versão do serviço. No versionamento por tipo de mídia, a versão faz parte do valor do cabeçalho Content Type ou do cabeçalho Accept. A definição fica assim: application barra vnd ponto myapi ponto v oito mais json por extenso, sinalizando que o conteúdo segue o formato da oitava versão. No versionamento por parâmetro de consulta, acrescenta-se ao final da URL uma interrogação seguida de version igual oito por extenso, como em barra pedidos interrogação version igual oito, para especificar a oitava versão do serviço. Cada uma dessas abordagens impacta as políticas de cache de forma diferente. No versionamento por URI e por parâmetro de consulta, caches e proxies tratam URLs distintas como recursos independentes, mantendo respostas separadas para cada versão. No versionamento por cabeçalho, é necessário configurar caches para levar em conta o valor do cabeçalho na chave de armazenamento. No versionamento por tipo de mídia, proxies baseados em inspecionar o cabeçalho Content Type determinam qual versão armazenar. A escolha deve levar em conta requisitos de desempenho, descoberta de serviços e compatibilidade com clientes antigos.
        vr_en: |
          Semantic versioning uses three full spoken numbers separated by the word dot in order of importance: major dot minor dot patch. For example, version eight dot zero dot zero indicates the eighth major release of the API, where breaking changes may occur. In URI versioning you insert the word slash followed by the letter v and the word eight in full before the resource path. For example slash v eight slash orders shows that you are accessing the eighth version of the orders API. In HTTP header versioning the client includes a header named Accept Version colon eight in full to tell the server that it wants to use the eighth version of the service. In media type versioning the version appears in the Content Type or Accept header value. It reads as application slash vnd dot myapi dot v eight plus json in full, indicating that the payload follows the eighth version format. In query parameter versioning you append a question mark followed by version equals eight in full at the end of the URL, such as slash orders question mark version equals eight, to specify the eighth version of the service. Each of these options modifies caching policies differently. With URI and query parameter versioning caches and proxies treat each distinct URL as a separate resource, storing responses per version. With header versioning caches must be configured to incorporate the header value into their storage key. With media type versioning proxies inspect the Content Type header to decide which version to cache. The choice should consider performance needs, service discoverability and backward compatibility with existing clients.
    - custom:
        vr_pt: |
          O versionamento semântico segue o formato numero ponto numero ponto numero por extenso, onde o primeiro número indica mudanças que quebram a compatibilidade, o segundo número sinaliza novas funcionalidades compatíveis e o terceiro número representa correções ou ajustes pequenos. Quando falamos da nona versão, dizemos nove ponto zero ponto zero para indicar que houve uma atualização principal com possíveis alterações de comportamento. No versionamento por URI, inserimos antes do caminho do recurso a barra seguida da letra v e da palavra nove por extenso. Por exemplo, ao acessar barra v nove barra pedidos, estamos solicitando a nona versão da API de pedidos. Essa abordagem torna cada versão facilmente identificável na rota, o que facilita a descoberta e o roteamento das requisições. No versionamento por cabeçalho HTTP, o cliente inclui na requisição um campo chamado Accept Versao seguido de dois pontos e da palavra nove por extenso. Esse cabeçalho comunica ao servidor que deve usar a nona versão da API, permitindo manter a URL limpa e centralizar a definição de versão na camada de transporte. No versionamento por tipo de mídia, a indicação da versão faz parte do valor do cabeçalho Content Type ou do cabeçalho Accept. Escrevemos application barra vnd ponto myapi ponto v nove mais json por extenso para sinalizar que o corpo da mensagem está no formato da nona versão. Essa técnica agrupa versão e formato de dados em um mesmo local, mas requer que intermediários analisem o cabeçalho de mídia. No versionamento por parâmetro de consulta, acrescenta-se ao final da URL uma interrogação seguida da palavra version igual e da palavra nove por extenso. Por exemplo, barra pedidos interrogação version igual nove define a nona versão do serviço. Esse padrão mantém a rota principal estável, mas exige atenção aos caches de query string e à clareza na documentação das URLs permitidas. Cada uma dessas escolhas afeta de maneira distinta a descoberta de endpoints e a compatibilidade com consumidores antigos. O versionamento por URI torna fácil visualizar no endereço qual versão está sendo usada, mas altera a rota. O versionamento por cabeçalho e por tipo de mídia mantém a rota inalterada, mas requer configuração em proxies e caches para respeitar o cabeçalho correto. O versionamento por parâmetro de consulta oferece flexibilidade sem mudar a rota base, mas precisa de regras claras para manipular strings de consulta sem conflitos.
        vr_en: |
          Semantic versioning follows the format number dot number dot number spoken in full, where the first number indicates breaking changes, the second number signals backward compatible feature additions, and the third number represents patches or minor fixes. When we refer to the ninth version we say nine dot zero dot zero to indicate a major release that may include behavior changes. In URI versioning, we insert before the resource path the slash followed by the letter v and the word nine in full. For example, when we call slash v nine slash orders we are requesting version nine of the orders API. This approach makes each version easily identifiable in the route, simplifying endpoint discovery and request routing. In HTTP header versioning, the client includes in the request a header named Accept Version colon followed by the word nine in full. This header tells the server to use version nine of the API, allowing the URL to remain clean and placing version control in the transport layer. In media type versioning, the version indication is part of the Content Type or Accept header value. We write application slash vnd dot myapi dot v nine plus json in full to signal that the message payload follows the ninth version format. This technique bundles version and data format in one location but requires intermediaries to inspect the media type header. In query parameter versioning, we append at the end of the URL a question mark followed by version equals and the word nine in full. For example, slash orders question mark version equals nine specifies version nine of the service. This pattern keeps the base route stable but demands careful handling of query string caches and clear documentation of allowed URL parameters. Each choice impacts endpoint discoverability and backward compatibility differently. URI versioning makes seeing which version is in use straightforward but alters the route. Header and media type versioning keep the route unchanged but require proxies and caches to be configured to honor the correct header. Query parameter versioning offers flexibility without changing the base route but needs clear rules for handling query strings without conflicts.
    - custom:
        vr_pt: |
          O versionamento semântico utiliza três números escritos por extenso separados pela palavra ponto: major ponto minor ponto patch. O primeiro número indica alterações que quebram a compatibilidade anterior, o segundo número sinaliza a inclusão de novas funcionalidades de forma compatível e o terceiro número representa correções de erros ou ajustes pequenos. No versionamento por URI, insere-se antes do caminho do recurso a barra seguida da letra v e do número dez por extenso. Por exemplo, barra v dez barra pedidos identifica a décima versão da API de pedidos, deixando claro na rota qual versão está sendo usada. No versionamento por cabeçalho HTTP, o cliente envia na requisição um campo chamado Accept Versão dois pontos seguido da palavra dez por extenso. Esse cabeçalho comunica ao servidor que a aplicação deseja acessar a API na décima versão sem alterar a URL. No versionamento por tipo de mídia, a versão é parte do valor do cabeçalho Content Type ou do cabeçalho Accept. Escreve-se application barra vnd ponto myapi ponto v dez mais json por extenso para indicar que o corpo da mensagem segue o formato da décima versão da API. No versionamento por parâmetro de consulta, adiciona-se ao final da URL uma interrogação seguida da palavra version igual dez por extenso. Por exemplo, barra pedidos interrogação version igual dez especifica que se deseja a décima versão do serviço sem mudar o caminho principal. Cada padrão de versionamento impacta de maneira única o ciclo de vida das APIs. No versionamento semântico fica claro quando há grandes mudanças ou apenas ajustes. No versionamento por URI e por parâmetro de consulta, cada versão gera uma rota distinta tratada como recurso separado em caches e servidores de rota. No versionamento por cabeçalho e por tipo de mídia, a rota permanece constante, mas requer configurações adicionais em intermediários para respeitar os valores de cabeçalho adequados. A escolha do padrão deve considerar requisitos de compatibilidade, descoberta de serviços, desempenho e facilidade de manutenção ao longo do tempo.
        vr_en: |
          Semantic versioning uses three full-spoken numbers separated by the word dot: major dot minor dot patch. The first number indicates breaking changes, the second signals backward-compatible feature additions, and the third represents bug fixes or minor tweaks. In URI versioning you insert before the resource path the slash followed by the letter v and the word ten in full. For example, slash v ten slash orders denotes version ten of the orders API, clearly showing in the route which version is in use. In HTTP header versioning the client sends a header named Accept Version colon followed by the word ten in full. This header tells the server that the application wants to access the API at version ten without changing the URL. In media type versioning the version is embedded in the Content Type or Accept header value. You write application slash vnd dot myapi dot v ten plus json in full to indicate that the message payload follows the format of version ten of the API. In query parameter versioning you append at the end of the URL a question mark followed by version equals ten in full. For example, slash orders question mark version equals ten specifies that version ten of the service is desired without altering the base path. Each versioning pattern uniquely affects the API lifecycle. Semantic versioning makes it clear when major changes occur versus minor tweaks. URI and query parameter versioning create distinct routes treated as separate resources by caches and routing layers. Header and media type versioning keep the route constant but require additional intermediary configuration to respect the correct header values. Choosing the right pattern should take into account compatibility, service discoverability, performance and long-term maintainability.
